# Task Scheduler  

It's a full-stack mobile application that helps you organize tasks. But it's not just a simple to-do listâ€”it's smart! When you create a task, the backend automatically analyzes your text to figure out the **category** (like Finance or Scheduling) and **priority**, and even suggests **next actions** for you.

---

## Tech Stack

I chose a modern stack to keep things fast, scalable, and developer-friendly.

### Backend
*   **FastAPI (Python):** I love Python, and FastAPI is incredibly fast and gives me automatic documentation.
*   **Supabase (PostgreSQL):** Used for the database. It's basically Postgres but with superpowers (and a great free tier).
*   **Pydantic:** Keeps my data clean and validated.

### Frontend
*   **Flutter (Dart):** Allows me to build a beautiful native mobile app from a single codebase.
*   **Riverpod:** For state management. It makes handling data flow in the app much cleaner than older solutions.
*   **Dio:** For handling HTTP requests.

---

## Setup Instructions


### 1. Backend Setup

First, get the backend running. You'll need Python 3.9+ installed.

1.  Navigate to the backend folder:
    ```bash
    cd backend
    ```

2.  Create and activate a virtual environment:
    ```bash
    python -m venv venv
    # Windows:
    venv\Scripts\activate
    # Mac/Linux:
    source venv/bin/activate
    ```

3.  Install dependencies:
    ```bash
    pip install -r requirements.txt
    ```

4.  **Environment Variables:** Create a `.env` file in the `backend` folder with your Supabase keys:
    ```env
    SUPABASE_URL=your_supabase_url
    SUPABASE_KEY=your_supabase_key
    ```

5.  **Database:** Run the SQL commands from `schema.sql` in your Supabase SQL editor to create the tables.

6.  Start the server:
    ```bash
    python run.py
    ```
    The API will run at `http://localhost:8000`.

### 2. Frontend Setup

Now for the mobile app. You'll need the Flutter SDK.

1.  Navigate to the app folder:
    ```bash
    cd flutter_app
    ```

2.  Get packages:
    ```bash
    flutter pub get
    ```

3.  **Important:** Check `lib/providers/task_provider.dart` and make sure the `baseUrl` points to your backend.
    *   If using Android Emulator: `http://10.0.2.2:8000`
    *   If using iOS Simulator: `http://localhost:8000`

4.  Run the app:
    ```bash
    flutter run
    ```

---

##  API Documentation

Here are the endpoints I implemented.

### Base URL
`http://localhost:8000`

### 1. Create Task
**POST** `/api/tasks`

Send a JSON body with the task details. The backend will handle the classification magic.
```json
{
  "title": "Pay the electricity bill",
  "description": "Due by Friday",
  "assigned_to": "Me"
}
```

### 2. Get All Tasks
**GET** `/api/tasks`

Supports pagination and filtering!
*   `?page=1&page_size=10`
*   `?category=finance`
*   `?priority=high`
*   `?search=bill`

### 3. Get Single Task
**GET** `/api/tasks/{id}`

### 4. Update Task
**PATCH** `/api/tasks/{id}`

Update only what you need.
```json
{
  "status": "completed"
}
```

### 5. Delete Task
**DELETE** `/api/tasks/{id}`

---

##  Database Schema

I used **PostgreSQL** because it's reliable and relational.

### `tasks` Table
Stores the main task data.
*   `id`: Primary Key
*   `title`, `description`: Basic info
*   `category`, `priority`: Auto-generated by backend
*   `extracted_entities`: JSON field storing dates/people found in text
*   `suggested_actions`: JSON list of suggested next steps

### `task_history` Table
Keeps an audit log of what changed.
*   `task_id`: Foreign Key
*   `action`: e.g., "created", "updated"
*   `changes`: JSON field showing what changed

---

## Screenshots

Here is what the app looks like!

| Task Dashboard | Create Task |
|:---:|:---:|
| ![Dashboard](screenshots/dashboard.png) | ![Create Task](screenshots/create_task.png) |

*(Note: If screenshots don't load, please check the `screenshots` folder in the repo!)*

---

##  Architecture Decisions

**Why Keyword Classification?**
I decided to build a custom keyword-based classifier instead of using an external AI API (like OpenAI). Why?
1.  **Speed:** It's instantaneous. No network latency waiting for a response.
2.  **Reliability:** It works offline (logic-wise) and doesn't depend on a 3rd party service going down.
3.  **Cost:** It's free! No token usage fees.
For this scope, it was the most pragmatic choice.

**Why Riverpod?**
I used Riverpod over Provider because it handles state dependencies much better and is compile-safe. It made handling the "loading", "data", and "error" states of the task list really straightforward.

---

##  What I'd Improve

If I had more time, here is what I would add next:

1.  **Better NLP:** Currently, the classification is simple. I'd love to integrate a small local ML model (like spaCy) for better entity recognition.
2.  **User Accounts:** Right now it's single-user. Adding Supabase Auth would allow multiple users to have their own private task lists.
3.  **Offline Mode:** I'd use a local SQLite database (via Drift or Hive) in Flutter to cache tasks so the app works perfectly without internet.
4.  **Push Notifications:** Reminders for due dates would be a great addition.

---


